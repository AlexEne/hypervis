#version 450

layout (local_size_x = 1) in;

struct Vertex4 {
    vec4 position;
    vec4 color;
};

struct DrawIndirectCommand {
    uint vertex_count;
    uint instance_count;
    uint first_vertex;
    uint first_instance;
};

layout(set = 0, binding = 0) uniform CutPlane {
    vec4 normal;
    float distance;
} cut_plane;

layout(set = 1, binding = 0) uniform SimplexCount {
    uint count;
} simplex_count;

layout(set = 1, binding = 1) buffer SrcVertices {
    Vertex4 vertices[];
} src_vertices;

layout(set = 1, binding = 2) buffer SrcIndices {
    uint indices[];
} src_indices;

layout(set = 2, binding = 0) buffer DrawCommand {
    DrawIndirectCommand command;
} dst_command;

layout(set = 2, binding = 1) buffer DstVertices {
    Vertex4 vertices[];
} dst_vertices;

bool cut_line_seg(vec4 start, vec4 end, out vec4 intersection, out float t) {
    vec4 b = end - start;
    float z = dot(b, cut_plane.normal);

    if (z != 0.) {
        t = (cut_plane.distance - dot(start, cut_plane.normal)) / z;
        if (0. < t && t < 1.) {
            intersection = start + t * b;
            return true;
        }
        else {
            return false;
        }
    }
    return false;
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index > simplex_count.count) {
        return;
    }

    Vertex4 a = src_vertices.vertices[src_indices.indices[index * 4 + 0]];
    Vertex4 b = src_vertices.vertices[src_indices.indices[index * 4 + 1]];
    Vertex4 c = src_vertices.vertices[src_indices.indices[index * 4 + 2]];
    Vertex4 d = src_vertices.vertices[src_indices.indices[index * 4 + 3]];

    Vertex4 result_vertices[6];
    uint emitted_vertices = 0;
    vec4 intersection;
    float t = 0.;

#define DETECT_INTERSECTION(x, y) do { \
        if (cut_line_seg((x).position, (y).position, intersection, t)) { \
            result_vertices[emitted_vertices].position = intersection; \
            result_vertices[emitted_vertices].color = mix((x).color, (y).color, t); \
            emitted_vertices++; \
        } \
    } while(false)

    DETECT_INTERSECTION(a, b);
    DETECT_INTERSECTION(a, c);
    DETECT_INTERSECTION(a, d);
    DETECT_INTERSECTION(b, c);
    DETECT_INTERSECTION(b, d);
    DETECT_INTERSECTION(c, d);

#define EMIT_TRIANGLE(i, a, b, c) do { \
        dst_vertices.vertices[i++] = result_vertices[a]; \
        dst_vertices.vertices[i++] = result_vertices[b]; \
        dst_vertices.vertices[i++] = result_vertices[c]; \
        dst_vertices.vertices[i++] = result_vertices[a]; \
        dst_vertices.vertices[i++] = result_vertices[c]; \
        dst_vertices.vertices[i++] = result_vertices[b]; \
    } while(false)

    if (emitted_vertices < 3) {
        // do nothing
        return;
    }
    else if (emitted_vertices == 3)
    {
        // emit a triangle
        uint i = atomicAdd(dst_command.command.vertex_count, 6);
        EMIT_TRIANGLE(i, 0, 1, 2);
    }
    else {
        // emit a tetrahedron
        uint i = atomicAdd(dst_command.command.vertex_count, 24);
        EMIT_TRIANGLE(i, 0, 1, 2);
        EMIT_TRIANGLE(i, 0, 2, 3);
        EMIT_TRIANGLE(i, 0, 1, 3);
        EMIT_TRIANGLE(i, 1, 2, 3);
    }
}
