#version 450

#define EPSILON 0.000001

layout (local_size_x = 1) in;

struct Vertex4 {
    vec4 position;
    vec4 color;
};

struct DrawIndirectCommand {
    uint vertex_count;
    uint instance_count;
    uint first_vertex;
    uint first_instance;
};

layout(set = 0, binding = 0) uniform CutPlane {
    vec4 normal;
    vec4 base_point;
    mat4 proj_matrix;
};

layout(set = 0, binding = 1) uniform RotationMatrix {
    mat4 rotation_matrix;
};

layout(set = 1, binding = 0) uniform SimplexCount {
    uint simplex_count;
};

layout(set = 1, binding = 1) buffer SrcVertices {
    Vertex4 src_vertices[];
};

layout(set = 1, binding = 2) buffer SrcIndices {
    uint src_indices[];
};

layout(set = 2, binding = 0) buffer DrawCommand {
    DrawIndirectCommand command;
};

layout(set = 2, binding = 1) buffer DstVertices {
    Vertex4 dst_vertices[];
};

bool cut_line_seg(vec4 start, vec4 end, vec4 normal, float distance, out vec4 intersection, out float t) {
    vec4 b = end - start;
    float z = dot(b, normal);

    if (abs(z) > EPSILON) {
        t = (distance - dot(start, normal)) / z;
        if (EPSILON < t && t - 1 < -EPSILON) {
            intersection = start + t * b;
            return true;
        }
        else {
            return false;
        }
    }
    return false;
}

vec4 project(vec4 x) {
    return vec4((proj_matrix * (x - base_point)).xyz, 1.0);
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index > simplex_count) {
        return;
    }

    float cut_plane_distance = dot(base_point, normal);

    Vertex4 a = src_vertices[src_indices[index * 4 + 0]];
    Vertex4 b = src_vertices[src_indices[index * 4 + 1]];
    Vertex4 c = src_vertices[src_indices[index * 4 + 2]];
    Vertex4 d = src_vertices[src_indices[index * 4 + 3]];
    a.position = rotation_matrix * a.position;
    b.position = rotation_matrix * b.position;
    c.position = rotation_matrix * c.position;
    d.position = rotation_matrix * d.position;

    Vertex4 result_vertices[4];
    uint emitted_vertices = 0;
    vec4 intersection;
    float t = 0.;

#define IN_PLANE(x) do { \
        if (abs(dot((x).position, normal) - cut_plane_distance) < EPSILON) { \
            result_vertices[emitted_vertices].position = project((x).position); \
            result_vertices[emitted_vertices].color = (x).color; \
            emitted_vertices++; \
        } \
    } while(false)

    IN_PLANE(a);
    IN_PLANE(b);
    IN_PLANE(c);
    IN_PLANE(d);

#define DETECT_INTERSECTION(x, y) do { \
        if (emitted_vertices < 4 && cut_line_seg((x).position, (y).position, normal, cut_plane_distance, intersection, t)) { \
            result_vertices[emitted_vertices].position = project(intersection); \
            result_vertices[emitted_vertices].color = mix((x).color, (y).color, t); \
            emitted_vertices++; \
        } \
    } while(false)

    DETECT_INTERSECTION(a, b);
    DETECT_INTERSECTION(a, c);
    DETECT_INTERSECTION(a, d);
    DETECT_INTERSECTION(b, c);
    DETECT_INTERSECTION(b, d);
    DETECT_INTERSECTION(c, d);

#define EMIT_TRIANGLE(i, a, b, c) do { \
        dst_vertices[i++] = result_vertices[a]; \
        dst_vertices[i++] = result_vertices[b]; \
        dst_vertices[i++] = result_vertices[c]; \
    } while(false)

    if (emitted_vertices < 3) {
        // do nothing
        return;
    }
    else if (emitted_vertices == 3)
    {
        // emit a triangle
        uint i = atomicAdd(command.vertex_count, 3);
        EMIT_TRIANGLE(i, 0, 1, 2);
    }
    else {
        // emit a tetrahedron
        uint i = atomicAdd(command.vertex_count, 12);
        EMIT_TRIANGLE(i, 0, 1, 2);
        EMIT_TRIANGLE(i, 0, 2, 3);
        EMIT_TRIANGLE(i, 0, 1, 3);
        EMIT_TRIANGLE(i, 1, 2, 3);
    }
}
