#version 450

#define EPSILON 0.000001
#define APPROX_ZERO(x) (abs(x) < EPSILON)
#define APPROX_EQ(a, b) (abs((a) - (b)) < EPSILON)
#define APPROX_VEC_EQ(a, b) (dot((a) - (b), (a) - (b)) < EPSILON)

layout (local_size_x = 1) in;

struct Vertex4 {
    vec4 position;
    vec4 color;
};

struct DrawIndirectCommand {
    uint vertex_count;
    uint instance_count;
    uint first_vertex;
    uint first_instance;
};

layout(set = 0, binding = 0) uniform CutPlane {
    vec4 normal;
    vec4 base_point;
    mat4 proj_matrix;
};

layout(set = 0, binding = 1) uniform RotationMatrix {
    mat4 rotation_matrix;
};

layout(set = 1, binding = 0) uniform SimplexCount {
    uint simplex_count;
};

layout(set = 1, binding = 1) buffer SrcVertices {
    Vertex4 src_vertices[];
};

layout(set = 1, binding = 2) buffer SrcIndices {
    uint src_indices[];
};

layout(set = 2, binding = 0) buffer DrawCommand {
    DrawIndirectCommand command;
};

layout(set = 2, binding = 1) buffer DstVertices {
    Vertex4 dst_vertices[];
};

bool cut_line_seg(vec4 start, vec4 end, vec4 normal, float distance, out vec4 intersection, out float t) {
    vec4 b = end - start;
    float z = dot(b, normal);

    if (!APPROX_ZERO(z)) {
        t = (distance - dot(start, normal)) / z;
        if (-EPSILON < t && 1 - t > -EPSILON) {
            intersection = start + t * b;
            return true;
        }
        else {
            return false;
        }
    }
    return false;
}

vec4 project(vec4 x) {
    return vec4((proj_matrix * (x - base_point)).xyz, 1.0);
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index > simplex_count) {
        return;
    }

    float cut_plane_distance = dot(base_point, normal);

    Vertex4 a = src_vertices[src_indices[index * 4 + 0]];
    Vertex4 b = src_vertices[src_indices[index * 4 + 1]];
    Vertex4 c = src_vertices[src_indices[index * 4 + 2]];
    Vertex4 d = src_vertices[src_indices[index * 4 + 3]];
    a.position = rotation_matrix * a.position;
    b.position = rotation_matrix * b.position;
    c.position = rotation_matrix * c.position;
    d.position = rotation_matrix * d.position;

    // check to see if the tetrahedron is exactly in the cut plane
    if (APPROX_EQ(dot(a.position, normal), cut_plane_distance)
        && APPROX_ZERO(dot(b.position - a.position, normal))
        && APPROX_ZERO(dot(c.position - a.position, normal))
        && APPROX_ZERO(dot(d.position - a.position, normal))) {

        a.color = vec4(1.0, 1.0, 1.0, 1.0);
        b.color = vec4(1.0, 1.0, 1.0, 1.0);
        c.color = vec4(1.0, 1.0, 1.0, 1.0);
        d.color = vec4(1.0, 1.0, 1.0, 1.0);

        // emit a tetrahedron
        uint i = atomicAdd(command.vertex_count, 12);
        dst_vertices[i++] = a;
        dst_vertices[i++] = b;
        dst_vertices[i++] = c;

        dst_vertices[i++] = a;
        dst_vertices[i++] = b;
        dst_vertices[i++] = d;

        dst_vertices[i++] = a;
        dst_vertices[i++] = c;
        dst_vertices[i++] = d;

        dst_vertices[i++] = b;
        dst_vertices[i++] = c;
        dst_vertices[i++] = d;
    }
    else {
        Vertex4 result_vertices[4];
        uint emitted_vertices = 0;
        vec4 intersection;
        float t = 0.;

#define DETECT_INTERSECTION(x, y) do { \
        if (emitted_vertices < 4 && cut_line_seg((x).position, (y).position, normal, cut_plane_distance, intersection, t)) { \
            vec4 projected_intersection = project(intersection); \
            for (int j = 0; j < 4; j++) { \
                if (j == emitted_vertices) { \
                    result_vertices[emitted_vertices].position = projected_intersection; \
                    result_vertices[emitted_vertices].color = mix((x).color, (y).color, t); \
                    emitted_vertices++; \
                    break; \
                } \
                if (APPROX_VEC_EQ(projected_intersection, result_vertices[j].position)) { \
                    break; \
                } \
            } \
        } \
    } while(false)

        DETECT_INTERSECTION(a, b);
        DETECT_INTERSECTION(c, a);
        DETECT_INTERSECTION(d, a);
        DETECT_INTERSECTION(b, c);
        DETECT_INTERSECTION(b, d);
        DETECT_INTERSECTION(c, d);

#define EMIT_TRIANGLE(i, a, b, c) do { \
        dst_vertices[i++] = result_vertices[a]; \
        dst_vertices[i++] = result_vertices[b]; \
        dst_vertices[i++] = result_vertices[c]; \
    } while(false)

        if (emitted_vertices < 3) {
            // do nothing
            return;
        }
        else if (emitted_vertices == 3)
        {
            // emit a triangle
            uint i = atomicAdd(command.vertex_count, 3);
            EMIT_TRIANGLE(i, 0, 1, 2);
        }
        else {
            // emit a quadrilateral
            uint i = atomicAdd(command.vertex_count, 12);
            EMIT_TRIANGLE(i, 0, 1, 2);
            EMIT_TRIANGLE(i, 0, 2, 3);
            EMIT_TRIANGLE(i, 0, 1, 3);
            EMIT_TRIANGLE(i, 1, 2, 3);
        }
    }
}
